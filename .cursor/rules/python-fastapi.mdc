---
description: 
globs: 
alwaysApply: true
---
# Python + FastAPI コーディング規約

## 基本方針
- **可読性**: コードを読む人（未来の自分含む）が理解しやすいコードを書く
- **保守性**: 変更や拡張が容易なコードを書く
- **パフォーマンス**: 適切なパフォーマンスを保ちつつ、過度な最適化は避ける

## Python 基本規則（PEP 8準拠）

### 命名規則
- **変数・関数**: snake_case
- **クラス**: PascalCase  
- **定数**: UPPER_CASE
- **プライベートメンバー**: 先頭に `_` を付ける
- **マジックメソッド以外のダンダーメソッド**: 使用禁止
- **パッケージ・モジュール**: 短い小文字、アンダースコア推奨しない

### 説明的命名（重要）
- **変数名**: 何を格納するかが明確に分かる名前
- **関数名**: 何をするかが明確に分かる動詞句
- **略語**: 一般的でない限り避ける
- **単文字変数**: ループカウンタ以外は禁止
- **ブール変数**: `is_`, `has_`, `can_`, `should_` などの接頭辞を使用

```python
# ✅ Good - 説明的な命名
user_authentication_token = "abc123"
is_user_authenticated = True
active_database_connections = []
MAX_PASSWORD_ATTEMPTS = 3

class EmailNotificationService:
    def send_password_reset_email(self, user_email_address: str) -> bool:
        """Send a password reset email to the specified address."""
        pass
    
    def validate_email_format(self, email_address: str) -> bool:
        """Check if the email address format is valid."""
        pass

def calculate_monthly_subscription_fee(
    base_price: Decimal,
    discount_percentage: float,
    tax_rate: float
) -> Decimal:
    """Calculate the final monthly fee including discount and tax."""
    discounted_price = base_price * (1 - discount_percentage / 100)
    final_price_with_tax = discounted_price * (1 + tax_rate)
    return final_price_with_tax

# 許可されるループカウンタの例
for user_index in range(len(users)):
    process_user(users[user_index])

# より良い方法
for current_user in users:
    process_user(current_user)

# ❌ Bad - 説明的でない命名  
token = "abc123"  # 何のトークン？
flag = True       # 何のフラグ？
data = []         # 何のデータ？
MAX_CNT = 3       # 何の最大値？

class EmailSvc:  # 略語は避ける
    def send(self, addr: str) -> bool:  # 何を送る？どこに？
        pass
    
    def chk(self, e: str) -> bool:  # 何をチェック？
        pass

def calc(p: float, d: float, t: float) -> float:  # 何を計算？
    result = p * (1 - d / 100) * (1 + t)
    return result

# 単文字変数の悪用
for i in range(len(users)):
    u = users[i]  # uは何？
    if u.active:  # activeな何？
        process(u)  # 何を処理？
```

### 文脈に応じた命名
- **コレクション**: 複数形を使用
- **辞書・マッピング**: `*_by_*` や `*_to_*` の形式
- **一時変数**: 用途が明確な場合のみ短縮可

```python
# ✅ Good - 文脈に応じた命名
active_users = get_active_users()
user_profiles_by_id = {user.id: user.profile for user in users}
email_to_user_mapping = create_email_mapping(users)

# 関数内の一時変数（用途が明確）
def format_user_display_name(first_name: str, last_name: str) -> str:
    """Format user's full name for display."""
    # 短い関数内なら省略形も許可
    full_name = f"{first_name} {last_name}".strip()
    return full_name.title()

# ❌ Bad
users = get_active_users()  # どんなusers？
mapping = {user.id: user.profile for user in users}  # 何のマッピング？
d = create_email_mapping(users)  # dは何？
```

### 行の長さ（PEP 8）
- **最大行長**: 79文字
- **docstring・コメント**: 72文字
- 長い行は適切に分割する

```python
# ✅ Good
result = some_function_with_a_long_name(
    argument_one, argument_two,
    argument_three, argument_four
)

# 演算子の前で改行
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)

# ❌ Bad
result = some_function_with_a_long_name(argument_one, argument_two, argument_three, argument_four)
```

### インデント（PEP 8）
- **スペース4個**を使用（タブ禁止）
- 継続行は適切にインデント

```python
# ✅ Good - 引数を縦に揃える
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# ✅ Good - 4スペースインデント
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)

# ❌ Bad - 引数と区別できない
foo = long_function_name(
var_one, var_two,
var_three, var_four)
```

### 空白行（PEP 8）
- **トップレベルのクラス・関数**: 前後に2行空ける
- **クラス内のメソッド**: 前後に1行空ける
- **関連する関数グループ**: 1行で区切る

```python
# ✅ Good
import os
import sys


class FirstClass:
    """First class."""

    def first_method(self):
        """First method."""
        pass

    def second_method(self):
        """Second method."""  
        pass


class SecondClass:
    """Second class."""
    pass


def top_level_function():
    """Top level function."""
    pass
```

### 空白の使用（PEP 8）
- **演算子の前後**: スペース1個
- **コンマ・セミコロン・コロンの後**: スペース1個
- **括弧内**: スペースなし
- **関数呼び出し**: 括弧前はスペースなし

```python
# ✅ Good
spam(ham[1], {eggs: 2})
x = 1
y = 2
long_variable = 3

if x == 4:
    print(x, y)

dct = {'key': 'value'}
lst = [1, 2, 3]

# ❌ Bad
spam( ham[ 1 ], { eggs: 2 } )
x=1
y=2
long_variable    = 3

if x==4:
    print(x,y)

dct = { 'key' : 'value' }
lst = [ 1, 2, 3 ]
```

### コメント（PEP 8）
- **インラインコメント**: `#` の後にスペース2個
- **ブロックコメント**: `#` の後にスペース1個
- **英語で記述**（プロジェクトが日本語の場合は日本語も可）
- **コードと矛盾しないよう保守**

```python
# ✅ Good
x = x + 1  # Increment x

# This is a block comment
# explaining the following code block
if condition:
    do_something()

# ❌ Bad
x = x + 1 #Increment x
x = x + 1    #Increment x
```

### 型ヒント
- すべての関数の引数と戻り値に型ヒントを付ける
- 複雑な型は `typing` モジュールを活用
- `Optional` よりも `| None` を使用（Python 3.10+）

```python
# ✅ Good
from typing import List, Dict, Optional

def process_users(users: List[User], config: Dict[str, Any]) -> List[User] | None:
    pass

# ❌ Bad
def process_users(users, config):
    pass
```

### インポート順序（PEP 8）
1. **標準ライブラリ**
2. **関連サードパーティライブラリ**  
3. **ローカルアプリケーション/ライブラリ**
- 各グループ間は空行で区切る
- グループ内はアルファベット順
- `from` インポートは `import` の後

```python
# ✅ Good
import os
import sys
from typing import List

import fastapi
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

from .models import User
from .services import UserService

# ❌ Bad
from .models import User
import os
from fastapi import FastAPI
import sys
from .services import UserService
from pydantic import BaseModel
```

### 関数とメソッド（PEP 8準拠）
- 1つの関数は1つの責任を持つ
- 関数の長さは**20-30行以内**を目安とする
- 複雑な条件は早期リターンを使用
- **docstring必須**（PEP 257準拠）
- 関数定義の括弧内で改行する場合は適切にインデント

```python
# ✅ Good
def get_active_user(user_id: int) -> User | None:
    """Return an active user by ID.
    
    Args:
        user_id: The user ID to look up.
        
    Returns:
        User object if found and active, None otherwise.
        
    Raises:
        ValueError: If user_id is invalid.
    """
    if user_id <= 0:
        raise ValueError("user_id must be positive")
        
    user = get_user_by_id(user_id)
    if user is None:
        return None
    
    if not user.is_active:
        return None
        
    return user


def complex_function_with_many_parameters(
        parameter_one: str,
        parameter_two: int,
        parameter_three: bool = False,
        parameter_four: Optional[Dict[str, Any]] = None
) -> ComplexReturnType:
    """Complex function with proper parameter formatting."""
    pass
```

## FastAPI 特有の規則

### ルーター構成
- 機能別にルーターファイルを分割
- ルーターのプレフィックスは複数形
- 各エンドポイントに適切なタグを設定

```python
# ✅ Good
# routers/users.py
from fastapi import APIRouter

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/")
async def get_users() -> List[UserResponse]:
    pass

@router.get("/{user_id}")
async def get_user(user_id: int) -> UserResponse:
    pass
```

### レスポンスモデル
- 必ずPydanticモデルを使用
- リクエスト用とレスポンス用でモデルを分ける
- バリデーションエラーは適切にハンドリング
- **説明的なモデル名**を使用

## Pydanticスキーマ設計（重要）

### 4層構造スキーマパターン
各エンティティに対して以下の4つのスキーマを作成：

```python
# ✅ Good - 4層構造によるスキーマ設計
from pydantic import BaseModel, Field, validator, EmailStr
from datetime import datetime
from uuid import UUID

# 1. ベーススキーマ（共通フィールド）
class UserBaseSchema(BaseModel):
    """User entity base schema with common fields."""
    username: str = Field(..., min_length=3, max_length=50, description="Unique username")
    email_address: EmailStr = Field(..., description="Valid email address")

# 2. 作成用スキーマ
class UserCreateRequest(UserBaseSchema):
    """Schema for user creation requests."""
    password: str = Field(..., min_length=8, description="User password (min 8 chars)")
    full_name: str = Field(..., min_length=1, max_length=100, description="User's full name")
    
    @validator('password')
    def validate_password_strength(cls, password_value):
        """Ensure password meets security requirements."""
        if not any(char.isupper() for char in password_value):
            raise ValueError('Password must contain at least one uppercase letter')
        if not any(char.islower() for char in password_value):
            raise ValueError('Password must contain at least one lowercase letter')
        if not any(char.isdigit() for char in password_value):
            raise ValueError('Password must contain at least one digit')
        return password_value

# 3. 更新用スキーマ
class UserUpdateRequest(BaseModel):
    """Schema for user update requests with optional fields."""
    username: str | None = Field(None, min_length=3, max_length=50)
    email_address: EmailStr | None = None
    full_name: str | None = Field(None, min_length=1, max_length=100)
    is_active: bool | None = None

# 4. レスポンス用スキーマ
class UserProfileResponse(UserBaseSchema):
    """User profile information for API responses."""
    user_id: UUID = Field(..., description="Unique user identifier")
    full_name: str = Field(..., description="User's full name")
    account_created_at: datetime = Field(..., description="Account creation timestamp")
    last_login_at: datetime | None = Field(None, description="Last login timestamp")
    is_active: bool = Field(True, description="Account active status")
    
    class Config:
        from_attributes = True
        json_encoders = {
            datetime: lambda dt: dt.isoformat(),
            UUID: lambda uuid_val: str(uuid_val)
        }
        schema_extra = {
            "example": {
                "user_id": "123e4567-e89b-12d3-a456-426614174000",
                "username": "johndoe",
                "email_address": "john@example.com",
                "full_name": "John Doe",
                "account_created_at": "2024-01-15T10:30:00Z",
                "is_active": True
            }
        }
```

### バリデーション設計
- フィールドレベルのバリデーションを活用
- カスタムバリデータで複雑な検証を実装
- 分かりやすいエラーメッセージを提供

```python
# ✅ Good - 詳細なバリデーション
class ContactInformationSchema(BaseModel):
    """Contact information with comprehensive validation."""
    phone_number: str = Field(..., description="Phone number in international format")
    country_code: str = Field(..., min_length=2, max_length=3, description="ISO country code")
    
    @validator('phone_number')
    def validate_phone_number_format(cls, phone_value):
        """Validate phone number format."""
        import re
        phone_pattern = re.compile(r'^\+?1?\d{9,15}

### 依存性注入
- データベース接続などは依存性注入を使用
- 共通のバリデーションは依存関数として定義
- 認証・認可は依存関数で実装
- **依存関数名は用途を明確に**

```python
# ✅ Good - 説明的な依存関数名
async def get_authenticated_user(
    authorization_token: str = Depends(oauth2_scheme)
) -> User:
    """Extract and validate user from authorization token."""
    # 認証ロジック
    pass

async def get_database_session() -> AsyncGenerator[AsyncSession, None]:
    """Provide database session with automatic cleanup."""
    async with async_session_factory() as session:
        yield session

async def validate_admin_permissions(
    current_user: User = Depends(get_authenticated_user)
) -> User:
    """Ensure current user has admin permissions."""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=403,
            detail="Administrator permissions required"
        )
    return current_user

@router.get("/admin/users")
async def get_all_users_for_admin(
    admin_user: User = Depends(validate_admin_permissions),
    db_session: AsyncSession = Depends(get_database_session)
) -> List[UserProfileResponse]:
    """Get all users (admin only endpoint)."""
    pass

# ❌ Bad - 説明的でない命名
async def get_user(token: str = Depends(oauth2_scheme)) -> User:
    pass

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    pass

async def check_admin(user: User = Depends(get_user)) -> User:
    pass
```

### エラーハンドリング
- 適切なHTTPステータスコードを使用
- エラーメッセージは分かりやすく
- 例外は適切にキャッチして変換
- **例外変数名は説明的に**

```python
# ✅ Good - 説明的な例外ハンドリング
@router.get("/users/{user_id}")
async def get_user_profile(user_id: int) -> UserProfileResponse:
    """Get user profile by ID."""
    try:
        user_profile = await user_service.get_user_profile_by_id(user_id)
        if user_profile is None:
            raise HTTPException(
                status_code=404,
                detail=f"User with ID {user_id} not found"
            )
        return UserProfileResponse.from_orm(user_profile)
    
    except DatabaseConnectionError as database_error:
        logger.error(f"Database connection failed: {database_error}")
        raise HTTPException(
            status_code=503,
            detail="Service temporarily unavailable"
        )
    
    except ValidationError as validation_error:
        logger.warning(f"Invalid user data: {validation_error}")
        raise HTTPException(
            status_code=422,
            detail="Invalid user data format"
        )

# ❌ Bad - 説明的でない例外ハンドリング
@router.get("/users/{user_id}")
async def get_user(user_id: int) -> UserResponse:
    try:
        user = await user_service.get(user_id)
        if user is None:
            raise HTTPException(status_code=404, detail="Not found")
        return UserResponse.from_orm(user)
    
    except Exception as e:  # 具体的でない例外キャッチ
        raise HTTPException(status_code=500, detail="Error")
```

## データベース・ORM

## データベース・ORM

## データベース・ORM

### プロジェクト構造（PostgreSQL + SQLAlchemy非同期）
PostgreSQL + SQLAlchemyの非同期プロジェクトでは、以下のディレクトリ構造を使用：

```
app/
├── core/
│   ├── config.py      # 設定管理（pydantic-settings使用）
│   └── logging.py     # ログ設定
├── db/
│   ├── __init__.py    # Database初期化クラス
│   ├── base.py        # SQLAlchemyベースクラス（UUID、タイムスタンプ付き）
│   └── session.py     # 非同期セッション管理
├── models/
│   └── *.py          # SQLAlchemyモデル（テーブルごとに分割）
├── schemas/
│   └── *.py          # Pydanticスキーマ（バリデーション用）
├── crud/
│   ├── exceptions.py  # カスタム例外クラス
│   └── *.py          # CRUD操作（テーブルごとに分割）
└── routers/
    └── *.py          # FastAPIルーター
```

### ベースクラス設計（db/base.py）
- PostgreSQLネイティブUUID型を主キーとして使用
- `created_at`, `updated_at`を自動管理
- タイムゾーン対応（PostgreSQL TIMESTAMPTZ）

```python
# ✅ Good - PostgreSQL用ベースクラス設計
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from sqlalchemy import DateTime, String
from sqlalchemy.dialects.postgresql import UUID
from datetime import datetime
from zoneinfo import ZoneInfo
import uuid

class DatabaseBaseModel(DeclarativeBase):
    """Base class for all database models with UUID and timestamps."""
    
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),  # PostgreSQLネイティブUUID型
        primary_key=True, 
        index=True, 
        default=uuid.uuid4,
        doc="Unique identifier for the record"
    )
    
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),  # PostgreSQL TIMESTAMPTZ
        default=lambda: datetime.now(ZoneInfo(settings.application_timezone)),
        doc="Record creation timestamp"
    )
    
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),  # PostgreSQL TIMESTAMPTZ
        default=lambda: datetime.now(ZoneInfo(settings.application_timezone)),
        onupdate=lambda: datetime.now(ZoneInfo(settings.application_timezone)),
        doc="Record last update timestamp"
    )
```

### モデル設計（models/*.py）
- `DatabaseBaseModel`を継承
- `__tablename__`を明示的に指定
- PostgreSQL固有の型とインデックスを活用
- `nullable=False`を明示的に指定

```python
# ✅ Good - PostgreSQL用SQLAlchemyモデル設計
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import String, Boolean, ForeignKey, Text, Index
from sqlalchemy.dialects.postgresql import UUID
from db.base import DatabaseBaseModel
import uuid

class UserAccountModel(DatabaseBaseModel):
    """User account database model for PostgreSQL."""
    __tablename__ = "user_accounts"
    
    username: Mapped[str] = mapped_column(
        String(50), 
        unique=True, 
        index=True, 
        nullable=False,
        doc="Unique username for the account"
    )
    
    email_address: Mapped[str] = mapped_column(
        String(254),  # RFC 5321準拠の最大長
        unique=True, 
        index=True, 
        nullable=False,
        doc="User's email address"
    )
    
    hashed_password: Mapped[str] = mapped_column(
        String(255), 
        nullable=False,
        doc="Hashed password for authentication"
    )
    
    is_active: Mapped[bool] = mapped_column(
        Boolean, 
        default=True, 
        nullable=False,
        index=True,  # 頻繁に検索されるため
        doc="Account active status"
    )
    
    is_email_verified: Mapped[bool] = mapped_column(
        Boolean, 
        default=False, 
        nullable=False,
        doc="Email verification status"
    )
    
    # PostgreSQL固有のインデックス定義
    __table_args__ = (
        Index('idx_user_accounts_active_email', 'is_active', 'email_address'),
        Index('idx_user_accounts_username_lower', 'username', postgresql_ops={'username': 'text_pattern_ops'}),
    )

class UserProfileModel(DatabaseBaseModel):
    """User profile database model for PostgreSQL."""
    __tablename__ = "user_profiles"
    
    user_account_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),  # PostgreSQLネイティブUUID型
        ForeignKey("user_accounts.id", ondelete="CASCADE"), 
        unique=True, 
        index=True, 
        nullable=False,
        doc="Reference to user account"
    )
    
    full_name: Mapped[str] = mapped_column(
        String(100), 
        nullable=False,
        doc="User's full name"
    )
    
    bio_description: Mapped[str | None] = mapped_column(
        Text,  # PostgreSQLのTEXT型（長いテキスト用）
        nullable=True,
        doc="User's biography"
    )
    
    profile_metadata: Mapped[dict | None] = mapped_column(
        # PostgreSQLのJSONB型（JSONデータ用）
        postgresql.JSONB,
        nullable=True,
        doc="Additional profile metadata in JSON format"
    )
    
    # リレーションシップ
    user_account: Mapped["UserAccountModel"] = relationship(
        "UserAccountModel", 
        back_populates="user_profile",
        lazy="selectin"  # N+1問題回避
    )

# UserAccountModelにリレーションシップを追加
UserAccountModel.user_profile = relationship(
    "UserProfileModel", 
    back_populates="user_account", 
    uselist=False,
    cascade="all, delete-orphan"  # カスケード削除
)
```

### セッション管理（db/session.py）
- `AsyncSessionLocal`を使用
- PostgreSQL用の適切な接続文字列設定
- 接続プール最適化

```python
# ✅ Good - PostgreSQL用非同期セッション管理
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.pool import NullPool
from core.config import database_settings
from typing import AsyncGenerator

# PostgreSQL用非同期エンジン作成
async_database_engine = create_async_engine(
    database_settings.database_connection_url,
    echo=database_settings.database_echo_queries,
    pool_size=database_settings.database_pool_size,
    max_overflow=database_settings.database_max_overflow,
    pool_pre_ping=True,
    pool_recycle=database_settings.database_pool_recycle_seconds,
    # PostgreSQL固有設定
    connect_args={
        "server_settings": {
            "jit": "off",  # JITコンパイラを無効（小規模なクエリでは遅くなる場合がある）
        }
    }
)

# 非同期セッションファクトリー
AsyncSessionLocal = async_sessionmaker(
    async_database_engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False,  # 明示的なflushを推奨
    autocommit=False
)

async def get_database_session() -> AsyncGenerator[AsyncSession, None]:
    """Provide database session with automatic cleanup."""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()

# メイン処理でのセッション使用パターン
async def example_database_transaction():
    """Example of proper PostgreSQL transaction usage."""
    async with AsyncSessionLocal() as session:
        try:
            # 複数のデータベース操作をトランザクションでまとめる
            user_account = await user_account_crud.create_user_account(session, user_data)
            user_profile = await user_profile_crud.create_user_profile(
                session, user_account.id, profile_data
            )
            
            # 明示的なコミット
            await session.commit()
            
            return {"user_account": user_account, "user_profile": user_profile}
            
        except Exception as database_error:
            await session.rollback()
            logger.error(f"Database transaction failed: {database_error}")
            raise
```

### CRUD操作設計（crud/*.py）
- PostgreSQL固有の機能を活用
- UPSERT操作（ON CONFLICT）の使用
- 適切なインデックスヒント

```python
# ✅ Good - PostgreSQL用CRUD操作設計
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError
from sqlalchemy import select, update, delete
from sqlalchemy.dialects.postgresql import insert  # PostgreSQL固有のINSERT
from crud.exceptions import (
    DuplicateUsernameError, 
    DuplicateEmailError, 
    DatabaseIntegrityError,
    UserNotFoundError
)
from core.logging import get_logger
import uuid

class UserAccountCRUDOperations:
    """CRUD operations for user accounts with PostgreSQL optimizations."""
    
    def __init__(self):
        self.logger = get_logger(__name__)
    
    async def create_user_account(
        self, 
        session: AsyncSession, 
        user_data: UserCreateRequest
    ) -> UserAccountModel:
        """Create a new user account with PostgreSQL optimizations."""
        self.logger.info(f"Creating new user account: {user_data.username}")
        
        try:
            new_user_account = UserAccountModel(
                username=user_data.username,
                email_address=user_data.email_address,
                hashed_password=hash_password(user_data.password)
            )
            
            session.add(new_user_account)
            await session.flush()  # Get ID without committing
            await session.refresh(new_user_account)  # リレーションシップをロード
            
            self.logger.info(f"User account created successfully: {new_user_account.id}")
            return new_user_account
            
        except IntegrityError as integrity_error:
            await session.rollback()
            error_message = str(integrity_error.orig).lower()
            
            # PostgreSQL固有のエラーメッセージ解析
            if "user_accounts_username_key" in error_message:
                self.logger.warning(f"Duplicate username attempt: {user_data.username}")
                raise DuplicateUsernameError(
                    f"Username '{user_data.username}' already exists"
                )
            elif "user_accounts_email_address_key" in error_message:
                self.logger.warning(f"Duplicate email attempt: {user_data.email_address}")
                raise DuplicateEmailError(
                    f"Email '{user_data.email_address}' already exists"
                )
            else:
                self.logger.error(f"Database integrity error: {integrity_error}")
                raise DatabaseIntegrityError("Database integrity constraint violated")
    
    async def get_user_account_by_id(
        self, 
        session: AsyncSession, 
        user_id: uuid.UUID
    ) -> UserAccountModel | None:
        """Get user account by UUID with optimized query."""
        self.logger.debug(f"Fetching user account by ID: {user_id}")
        
        # PostgreSQLのインデックスを活用した効率的なクエリ
        query_result = await session.execute(
            select(UserAccountModel)
            .where(UserAccountModel.id == user_id)
            .options(selectinload(UserAccountModel.user_profile))  # N+1問題回避
        )
        
        user_account = query_result.scalar_one_or_none()
        
        if user_account:
            self.logger.debug(f"User account found: {user_account.username}")
        else:
            self.logger.debug(f"User account not found for ID: {user_id}")
            
        return user_account
    
    async def upsert_user_account(
        self, 
        session: AsyncSession, 
        user_data: UserCreateRequest
    ) -> tuple[UserAccountModel, bool]:
        """PostgreSQL UPSERT operation using ON CONFLICT."""
        self.logger.info(f"Upserting user account: {user_data.username}")
        
        # PostgreSQL固有のUPSERT（INSERT ... ON CONFLICT）
        stmt = insert(UserAccountModel).values(
            username=user_data.username,
            email_address=user_data.email_address,
            hashed_password=hash_password(user_data.password)
        )
        
        # 競合時の処理（例：usernameが重複した場合は更新）
        upsert_stmt = stmt.on_conflict_do_update(
            index_elements=['username'],
            set_=dict(
                email_address=stmt.excluded.email_address,
                updated_at=func.now()
            )
        ).returning(UserAccountModel)
        
        result = await session.execute(upsert_stmt)
        user_account = result.scalar_one()
        
        # 新規作成か更新かを判定
        was_created = user_account.created_at == user_account.updated_at
        
        self.logger.info(
            f"User account {'created' if was_created else 'updated'}: {user_account.id}"
        )
        
        return user_account, was_created

# CRUD操作のインスタンス
user_account_crud = UserAccountCRUDOperations()
```

### 例外処理（crud/exceptions.py）
```python
# ✅ Good - カスタム例外クラス
class DatabaseOperationError(Exception):
    """Base exception for database operations."""
    pass

class UserNotFoundError(DatabaseOperationError):
    """Raised when user is not found."""
    pass

class DuplicateUsernameError(DatabaseOperationError):
    """Raised when username already exists."""
    pass

class DuplicateEmailError(DatabaseOperationError):
    """Raised when email already exists."""
    pass

class DatabaseIntegrityError(DatabaseOperationError):
    """Raised when database integrity constraint is violated."""
    pass
```

### マイグレーション
- Alembicを使用してマイグレーションを管理
- マイグレーションファイルには分かりやすい名前を付ける
- ダウングレードも考慮する

## テスト

### テスト構成
- pytest + httpx を使用
- テストは機能別にファイルを分割
- テストデータはfixtureで管理

```python
# ✅ Good
@pytest.fixture
async def test_user():
    return User(name="Test User", email="test@example.com")

async def test_get_user_success(test_client, test_user):
    response = await test_client.get(f"/users/{test_user.id}")
    assert response.status_code == 200
    assert response.json()["name"] == test_user.name
```

## パフォーマンス考慮事項

### データベースクエリ
- 必要なデータのみを取得（select specific columns）
- インデックスを適切に設定
- 複雑なクエリはSQLで直接記述することも検討

### 非同期処理
- I/O操作は必ずasync/awaitを使用
- CPU集約的な処理はbackground tasksを使用
- 適切にconnection poolingを設定

### キャッシュ
- 頻繁にアクセスされる静的データはキャッシュ
- Redis等の外部キャッシュを活用
- キャッシュの無効化戦略を明確にする

### 設定管理（core/config.py）
- `pydantic_settings`でPostgreSQL設定を管理
- `model_config`を使用した環境変数設定
- 適切な接続文字列とパラメータ

```python
# ✅ Good - PostgreSQL用設定管理（model_config使用）
import os
from pydantic import ConfigDict, Field
from pydantic_settings import BaseSettings
from typing import Optional, Literal

class ApplicationSettings(BaseSettings):
    """Application configuration settings with PostgreSQL support."""
    
    # 環境設定
    ENVIRONMENT: Literal["development", "testing", "production"] = "development"
    
    # ロギング設定
    LOG_LEVEL: str = "INFO"
    LOG_TO_FILE: bool = False
    LOG_FILE_PATH: str = "logs/fastapi_app.log"
    
    # PostgreSQL データベース設定
    POSTGRES_HOST: str = Field(..., description="PostgreSQL host")
    POSTGRES_INTERNAL_PORT: str = Field(default="5432", description="PostgreSQL internal port")
    POSTGRES_USER: str = Field(..., description="PostgreSQL username")
    POSTGRES_PASSWORD: str = Field(..., description="PostgreSQL password")
    POSTGRES_DB: str = Field(..., description="PostgreSQL database name")
    POSTGRES_EXTERNAL_PORT: str = Field(..., description="PostgreSQL external port")
    
    # データベース詳細設定
    DATABASE_POOL_SIZE: int = Field(default=10, description="Database connection pool size")
    DATABASE_MAX_OVERFLOW: int = Field(default=20, description="Maximum overflow connections")
    DATABASE_POOL_RECYCLE_SECONDS: int = Field(default=3600, description="Pool recycle time")
    DATABASE_COMMAND_TIMEOUT: int = Field(default=60, description="Command timeout in seconds")
    DATABASE_STATEMENT_TIMEOUT: int = Field(default=30000, description="Statement timeout in ms")
    
    # SQLAlchemy設定
    SQLALCHEMY_ECHO: bool = Field(default=False, description="Enable SQLAlchemy query logging")
    
    # Redis設定
    REDIS_HOST: str = Field(default="redis", description="Redis host")
    REDIS_PORT: str = Field(default="6379", description="Redis port")
    REDIS_PASSWORD: Optional[str] = Field(default=None, description="Redis password")
    REDIS_EXTERNAL_PORT: str = Field(..., description="Redis external port")
    
    # タイムゾーン設定
    TZ: str = Field(default="Asia/Tokyo", description="Application timezone")
    
    # JWT認証設定
    JWT_ALGORITHM: str = Field(default="RS256", description="JWT algorithm")
    JWT_PRIVATE_KEY_PATH: str = Field(default="keys/private.pem", description="JWT private key path")
    JWT_PUBLIC_KEY_PATH: str = Field(default="keys/public.pem", description="JWT public key path")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = Field(default=30, description="Access token expiration")
    REFRESH_TOKEN_EXPIRE_DAYS: int = Field(default=7, description="Refresh token expiration")
    
    # セキュリティ設定
    SECRET_KEY: str = Field(..., description="Application secret key")
    TOKEN_BLACKLIST_ENABLED: bool = Field(default=True, description="Enable token blacklist")
    
    # CORS設定
    CORS_ALLOWED_ORIGINS: list[str] = Field(
        default=["http://localhost:3000", "http://localhost:8000"],
        description="CORS allowed origins"
    )
    
    # API設定
    API_V1_PREFIX: str = Field(default="/api/v1", description="API v1 prefix")
    APP_NAME: str = Field(default="FastAPI Application", description="Application name")
    APP_VERSION: str = Field(default="1.0.0", description="Application version")
    
    @property
    def database_connection_url(self) -> str:
        """Generate PostgreSQL connection URL for SQLAlchemy."""
        return (
            f"postgresql+asyncpg://"
            f"{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@"
            f"{self.POSTGRES_HOST}:{self.POSTGRES_INTERNAL_PORT}/"
            f"{self.POSTGRES_DB}"
        )
    
    @property
    def redis_connection_url(self) -> str:
        """Generate Redis connection URL."""
        if self.REDIS_PASSWORD:
            return f"redis://:{self.REDIS_PASSWORD}@{self.REDIS_HOST}:{self.REDIS_PORT}/0"
        return f"redis://{self.REDIS_HOST}:{self.REDIS_PORT}/0"
    
    @property
    def jwt_private_key(self) -> str:
        """Load JWT private key from file or environment variable."""
        try:
            with open(self.JWT_PRIVATE_KEY_PATH, "r") as private_key_file:
                return private_key_file.read()
        except FileNotFoundError:
            # フォールバック：環境変数から読み込み
            private_key_content = os.environ.get("JWT_PRIVATE_KEY", "")
            if not private_key_content:
                raise ValueError(f"JWT private key not found at {self.JWT_PRIVATE_KEY_PATH}")
            return private_key_content
    
    @property
    def jwt_public_key(self) -> str:
        """Load JWT public key from file or environment variable."""
        try:
            with open(self.JWT_PUBLIC_KEY_PATH, "r") as public_key_file:
                return public_key_file.read()
        except FileNotFoundError:
            # フォールバック：環境変数から読み込み
            public_key_content = os.environ.get("JWT_PUBLIC_KEY", "")
            if not public_key_content:
                raise ValueError(f"JWT public key not found at {self.JWT_PUBLIC_KEY_PATH}")
            return public_key_content
    
    @property
    def is_development_environment(self) -> bool:
        """Check if running in development environment."""
        return self.ENVIRONMENT == "development"
    
    @property
    def is_production_environment(self) -> bool:
        """Check if running in production environment."""
        return self.ENVIRONMENT == "production"
    
    @property
    def database_echo_enabled(self) -> bool:
        """Determine if database query echoing should be enabled."""
        return self.SQLALCHEMY_ECHO and self.is_development_environment
    
    model_config = ConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=True,  # 環境変数の大文字小文字を区別
        extra="ignore",       # 未定義の環境変数を無視
        validate_default=True # デフォルト値もバリデーション
    )

# アプリケーション全体で使用する設定インスタンス
application_settings = ApplicationSettings()

# 後方互換性のためのエイリアス
settings = application_settings

# ✅ Good - 設定値の使用例
async def create_database_engine():
    """Create database engine with settings."""
    from sqlalchemy.ext.asyncio import create_async_engine
    
    return create_async_engine(
        application_settings.database_connection_url,
        echo=application_settings.database_echo_enabled,
        pool_size=application_settings.DATABASE_POOL_SIZE,
        max_overflow=application_settings.DATABASE_MAX_OVERFLOW,
        pool_recycle=application_settings.DATABASE_POOL_RECYCLE_SECONDS,
        connect_args={
            "command_timeout": application_settings.DATABASE_COMMAND_TIMEOUT,
            "server_settings": {
                "application_name": application_settings.APP_NAME,
                "statement_timeout": str(application_settings.DATABASE_STATEMENT_TIMEOUT),
                "jit": "off",
            }
        }
    )

# ❌ Bad - model_config非使用の古い形式
class OldStyleSettings(BaseSettings):
    database_url: str
    
    class Config:  # 非推奨
        env_file = ".env"
        env_file_encoding = "utf-8"
```

### 環境変数ファイル（.env）サンプル
```bash
# .env ファイルの例
ENVIRONMENT=development

# PostgreSQL設定
POSTGRES_HOST=localhost
POSTGRES_INTERNAL_PORT=5432
POSTGRES_EXTERNAL_PORT=5433
POSTGRES_USER=fastapi_user
POSTGRES_PASSWORD=secure_password_123
POSTGRES_DB=fastapi_application

# Redis設定
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_EXTERNAL_PORT=6380
REDIS_PASSWORD=redis_password_123

# 認証設定
SECRET_KEY=your-super-secret-key-change-in-production
ACCESS_TOKEN_EXPIRE_MINUTES=30
REFRESH_TOKEN_EXPIRE_DAYS=7

# ログ設定
LOG_LEVEL=DEBUG
LOG_TO_FILE=true
LOG_FILE_PATH=logs/app.log

# SQLAlchemy設定
SQLALCHEMY_ECHO=true

# タイムゾーン
TZ=Asia/Tokyo
```

### 必須依存関係パッケージ
PostgreSQL + SQLAlchemy非同期プロジェクトに必要なパッケージ：

```toml
# pyproject.toml
[project]
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn[standard]>=0.24.0",
    "sqlalchemy[asyncio]>=2.0.0",  # 非同期SQLAlchemy
    "asyncpg>=0.29.0",             # PostgreSQL非同期ドライバー（高性能）
    "psycopg[binary,pool]>=3.1.0", # PostgreSQL同期ドライバー（マイグレーション用）
    "alembic>=1.13.0",             # データベースマイグレーション
    "pydantic>=2.5.0",
    "pydantic-settings>=2.1.0",   # 設定管理
    "email-validator>=2.1.0",     # メールアドレス検証
    "python-multipart>=0.0.6",    # フォームデータ処理
    "python-jose[cryptography]>=3.3.0",  # JWT処理
    "passlib[bcrypt]>=1.7.4",     # パスワードハッシュ化
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.0",
    "pytest-asyncio>=0.21.0",
    "httpx>=0.25.0",              # テスト用HTTPクライアント
    "pytest-postgresql>=5.0.0",   # テスト用PostgreSQLインスタンス
]
```

### Alembicマイグレーション設定
PostgreSQL用のAlembic設定例：

```python
# alembic/env.py
from alembic import context
from sqlalchemy import engine_from_config, pool
from sqlalchemy.ext.asyncio import AsyncEngine
from core.config import database_settings
from db.base import DatabaseBaseModel

# Alembicの設定
config = context.config

# データベースURL設定
config.set_main_option("sqlalchemy.url", database_settings.database_connection_url)

# メタデータ設定
target_metadata = DatabaseBaseModel.metadata

def run_migrations_online():
    """Run migrations in 'online' mode for PostgreSQL."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
            # PostgreSQL固有の設定
            compare_type=True,
            compare_server_default=True,
            render_as_batch=False,  # PostgreSQLではFalse
        )

        with context.begin_transaction():
            context.run_migrations()
```

### Pydantic Settings
- 環境変数は `pydantic_settings` で管理
- 型安全な設定クラスを作成
- 環境別設定を適切に分離

```python
# ✅ Good - Settings管理
from pydantic_settings import BaseSettings
from pydantic import Field

class ApplicationSettings(BaseSettings):
    """Application configuration settings."""
    
    # Database settings
    database_connection_url: str = Field(
        default="sqlite:///./app.db",
        description="Database connection URL"
    )
    database_pool_size: int = Field(default=5, description="Database connection pool size")
    
    # Security settings
    secret_key_for_jwt: str = Field(..., description="JWT secret key")
    jwt_token_expire_minutes: int = Field(default=30, description="JWT expiration time")
    password_hash_algorithm: str = Field(default="bcrypt", description="Password hashing algorithm")
    
    # Application settings
    application_name: str = Field(default="FastAPI App", description="Application name")
    debug_mode_enabled: bool = Field(default=False, description="Enable debug mode")
    cors_allowed_origins: list[str] = Field(default=["*"], description="CORS allowed origins")
    
    # External service settings
    email_service_api_key: str | None = Field(None, description="Email service API key")
    redis_cache_url: str = Field(default="redis://localhost:6379", description="Redis cache URL")
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"
        case_sensitive = False
        # 環境変数のプレフィックス
        env_prefix = "APP_"

# アプリケーション全体で使用する設定インスタンス
application_settings = ApplicationSettings()
```

## セキュリティ

### 認証・認可
- JWT トークンは適切に検証
- パスワードは必ずハッシュ化
- 権限チェックは各エンドポイントで実施

### 入力値検証
- Pydanticのバリデーションを活用
- SQLインジェクション対策（ORMの適切な使用）
- XSS対策（適切なエスケープ）

## コード品質（PEP 8準拠）

### Linting & Formatting
- **Black**（フォーマッター）- PEP 8準拠
- **isort**（インポート順序）- PEP 8準拠  
- **flake8**（リンター）- PEP 8チェック
- **mypy**（型チェック）
- **設定例**:

```ini
# setup.cfg
[flake8]
max-line-length = 79
extend-ignore = E203, W503
exclude = .git,__pycache__,migrations

[isort]
profile = black
line_length = 79
multi_line_output = 3

[tool:pytest]
testpaths = tests
```

### Pre-commit hooks
- 上記ツールをpre-commitで自動実行
- PEP 8違反を自動修正
- テストも自動実行

## 禁止事項（PEP 8準拠）

### 禁止事項（PEP 8準拠）

#### Pydanticアンチパターン
- **型ヒントなし**: すべてのフィールドに適切な型を指定
- **バリデーションなし**: 入力値の検証を省略
- **不適切なモデル分離**: 同じモデルをリクエスト・レスポンスで使い回し
- **説明的でないフィールド名**: `data`, `info`, `val` などの曖昧な名前

```python
# ❌ Bad - Pydanticアンチパターン
class User(BaseModel):  # リクエスト・レスポンス共用（NG）
    id: int
    name: str           # バリデーションなし
    email: str          # EmailStrを使わない
    pwd: str            # パスワードが平文でレスポンスに含まれる
    data: dict          # 曖昧なフィールド名

class BadRequest(BaseModel):
    info: str           # 何の情報？
    val: int            # 何の値？
    stuff: list         # 何のリスト？

# ✅ Good - 適切なPydanticパターン
class UserCreateRequest(BaseModel):
    full_name: str = Field(..., min_length=1, max_length=100)
    email_address: EmailStr
    password: str = Field(..., min_length=8)
    
    @validator('password')
    def validate_password_strength(cls, password_value):
        # パスワード強度チェック
        return password_value

class UserProfileResponse(BaseModel):
    user_id: UUID
    full_name: str
    email_address: str
    account_created_at: datetime
    # パスワードは含まない
    
    class Config:
        from_attributes = True
```

#### 避けるべきパターン
- **タブとスペースの混在**（スペースのみ使用）
- **行末の空白**
- **魔法の数値**（マジックナンバー）
- **深すぎるネスト**（4レベル以上）
- **長すぎる関数**（30行以上）
- **PEP 8違反**（行の長さ、空白使用など）

```python
# ❌ Bad - PEP 8違反例
def process_data(data):
    # 行が長すぎる
    result = some_very_long_function_name_that_exceeds_the_line_limit(argument_one, argument_two, argument_three)
    
    # 空白の使い方が間違い
    for item in data:
        if item>10:# コメントの前にスペースがない
            if item<100:
                if item%2==0:# 演算子の前後にスペースがない
                    if item!=50:# ネストが深すぎる
                        pass

# ✅ Good - PEP 8準拠
MAX_THRESHOLD = 10
MIN_THRESHOLD = 100

def process_data(data: List[int]) -> List[int]:
    """Process data according to business rules."""
    result = []
    
    for item in data:
        if item <= MAX_THRESHOLD:
            continue
            
        if item >= MIN_THRESHOLD:
            continue
            
        if item % 2 == 0 and item != 50:
            result.append(item)
            
    return result
```

### パフォーマンスの罠
- 同期処理のDB操作
- N+1クエリ
- 不必要なデータの取得
- メモリリークの原因となるコード

## まとめ

このコーディング規約は、**可読性**、**保守性**、**パフォーマンス**のバランスを重視しています。

- コードは書くよりも読まれることが多いため、可読性を最優先
- 将来の変更に対応できるよう、適切な抽象化と分離を実施
- パフォーマンスは測定可能な問題が発生してから最適化

規約は必要に応じて進化させ、プロジェクトの成長に合わせて調整してください。)
        if not phone_pattern.match(phone_value):
            raise ValueError('Phone number must be 9-15 digits with optional + prefix')
        return phone_value
    
    @validator('country_code')
    def validate_country_code_format(cls, country_code_value):
        """Ensure country code is uppercase."""
        return country_code_value.upper()

# ❌ Bad - バリデーションが不十分
class ContactSchema(BaseModel):
    phone: str
    country: str
```

### 型ヒント（Python 3.10+）
- `Union` よりも `|` を使用
- `Optional` よりも `| None` を使用

```python
# ✅ Good - 新しい型ヒント記法
class UserUpdateRequest(BaseModel):
    username: str | None = None
    email_address: EmailStr | None = None
    preferences: dict[str, str] | None = None
    tags: list[str] = []

# ❌ Bad - 古い型ヒント記法
from typing import Optional, Union, List, Dict

class UserUpdateRequest(BaseModel):
    username: Optional[str] = None
    email_address: Union[EmailStr, None] = None
    preferences: Optional[Dict[str, str]] = None
    tags: List[str] = []
```

### 特殊フィールド型の活用
```python
# ✅ Good - 適切な特殊型の使用
from pydantic import EmailStr, HttpUrl, UUID4, SecretStr
from decimal import Decimal

class ComprehensiveUserProfile(BaseModel):
    """Comprehensive user profile with various field types."""
    user_id: UUID4 = Field(..., description="Unique user identifier")
    email_address: EmailStr = Field(..., description="Validated email address")
    profile_website: HttpUrl | None = Field(None, description="User's website URL")
    hashed_password: SecretStr = Field(..., description="Securely stored password")
    account_balance: Decimal = Field(default=Decimal('0.00'), description="Account balance")
    profile_tags: list[str] = Field(default=[], description="User profile tags")
    metadata: dict[str, str] = Field(default={}, description="Additional metadata")
    registration_timestamp: datetime = Field(..., description="Account registration time")
```

### ネストしたスキーマ
- 関連エンティティは適切にネスト
- 循環参照を避ける

```python
# ✅ Good - ネストしたスキーマ
class UserAddressResponse(BaseModel):
    """User address information."""
    address_id: UUID = Field(..., description="Address unique identifier")
    street_address: str = Field(..., description="Street address")
    city_name: str = Field(..., description="City name")
    postal_code: str = Field(..., description="Postal/ZIP code")
    country_code: str = Field(..., description="ISO country code")
    
    class Config:
        from_attributes = True

class DetailedUserProfileResponse(UserProfileResponse):
    """Detailed user profile with nested address information."""
    primary_address: UserAddressResponse | None = Field(
        None, description="User's primary address"
    )
    billing_addresses: list[UserAddressResponse] = Field(
        default=[], description="User's billing addresses"
    )
```

### 依存性注入
- データベース接続などは依存性注入を使用
- 共通のバリデーションは依存関数として定義
- 認証・認可は依存関数で実装
- **依存関数名は用途を明確に**

```python
# ✅ Good - 説明的な依存関数名
async def get_authenticated_user(
    authorization_token: str = Depends(oauth2_scheme)
) -> User:
    """Extract and validate user from authorization token."""
    # 認証ロジック
    pass

async def get_database_session() -> AsyncGenerator[AsyncSession, None]:
    """Provide database session with automatic cleanup."""
    async with async_session_factory() as session:
        yield session

async def validate_admin_permissions(
    current_user: User = Depends(get_authenticated_user)
) -> User:
    """Ensure current user has admin permissions."""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=403,
            detail="Administrator permissions required"
        )
    return current_user

@router.get("/admin/users")
async def get_all_users_for_admin(
    admin_user: User = Depends(validate_admin_permissions),
    db_session: AsyncSession = Depends(get_database_session)
) -> List[UserProfileResponse]:
    """Get all users (admin only endpoint)."""
    pass

# ❌ Bad - 説明的でない命名
async def get_user(token: str = Depends(oauth2_scheme)) -> User:
    pass

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    pass

async def check_admin(user: User = Depends(get_user)) -> User:
    pass
```

### エラーハンドリング
- 適切なHTTPステータスコードを使用
- エラーメッセージは分かりやすく
- 例外は適切にキャッチして変換
- **例外変数名は説明的に**

```python
# ✅ Good - 説明的な例外ハンドリング
@router.get("/users/{user_id}")
async def get_user_profile(user_id: int) -> UserProfileResponse:
    """Get user profile by ID."""
    try:
        user_profile = await user_service.get_user_profile_by_id(user_id)
        if user_profile is None:
            raise HTTPException(
                status_code=404,
                detail=f"User with ID {user_id} not found"
            )
        return UserProfileResponse.from_orm(user_profile)
    
    except DatabaseConnectionError as database_error:
        logger.error(f"Database connection failed: {database_error}")
        raise HTTPException(
            status_code=503,
            detail="Service temporarily unavailable"
        )
    
    except ValidationError as validation_error:
        logger.warning(f"Invalid user data: {validation_error}")
        raise HTTPException(
            status_code=422,
            detail="Invalid user data format"
        )

# ❌ Bad - 説明的でない例外ハンドリング
@router.get("/users/{user_id}")
async def get_user(user_id: int) -> UserResponse:
    try:
        user = await user_service.get(user_id)
        if user is None:
            raise HTTPException(status_code=404, detail="Not found")
        return UserResponse.from_orm(user)
    
    except Exception as e:  # 具体的でない例外キャッチ
        raise HTTPException(status_code=500, detail="Error")
```

## データベース・ORM

### SQLAlchemy（Async）
- 非同期セッションを使用
- トランザクション管理を適切に行う
- N+1問題を避けるため、適切にjoinloadを使用
- **クエリ関数名は取得データを明確に**

```python
# ✅ Good - 説明的なクエリ関数
async def get_user_with_active_subscriptions(user_id: int) -> User | None:
    """Get user with their active subscription details."""
    async with get_database_session() as session:
        query_result = await session.execute(
            select(User)
            .options(selectinload(User.subscriptions.and_(
                Subscription.is_active == True
            )))
            .where(User.id == user_id)
        )
        return query_result.scalar_one_or_none()

async def get_users_by_registration_date_range(
    start_date: date,
    end_date: date,
    limit: int = 100
) -> List[User]:
    """Get users who registered within specified date range."""
    async with get_database_session() as session:
        query_result = await session.execute(
            select(User)
            .where(
                User.registration_date.between(start_date, end_date)
            )
            .order_by(User.registration_date.desc())
            .limit(limit)
        )
        return query_result.scalars().all()

async def count_active_users_by_subscription_type(
    subscription_type: str
) -> int:
    """Count active users with specific subscription type."""
    async with get_database_session() as session:
        query_result = await session.execute(
            select(func.count(User.id))
            .join(Subscription)
            .where(
                and_(
                    User.is_active == True,
                    Subscription.type == subscription_type,
                    Subscription.is_active == True
                )
            )
        )
        return query_result.scalar()

# ❌ Bad - 説明的でない命名
async def get_user(user_id: int) -> User | None:
    async with get_db() as session:
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        return result.scalar_one_or_none()

async def get_users(start: date, end: date) -> List[User]:
    async with get_db() as session:
        result = await session.execute(
            select(User).where(User.date.between(start, end))
        )
        return result.scalars().all()
```

### マイグレーション
- Alembicを使用してマイグレーションを管理
- マイグレーションファイルには分かりやすい名前を付ける
- ダウングレードも考慮する

## テスト

### テスト構成
- pytest + httpx を使用
- テストは機能別にファイルを分割
- テストデータはfixtureで管理

```python
# ✅ Good
@pytest.fixture
async def test_user():
    return User(name="Test User", email="test@example.com")

async def test_get_user_success(test_client, test_user):
    response = await test_client.get(f"/users/{test_user.id}")
    assert response.status_code == 200
    assert response.json()["name"] == test_user.name
```

## パフォーマンス考慮事項

### データベースクエリ
- 必要なデータのみを取得（select specific columns）
- インデックスを適切に設定
- 複雑なクエリはSQLで直接記述することも検討

### 非同期処理
- I/O操作は必ずasync/awaitを使用
- CPU集約的な処理はbackground tasksを使用
- 適切にconnection poolingを設定

### キャッシュ
- 頻繁にアクセスされる静的データはキャッシュ
- Redis等の外部キャッシュを活用
- キャッシュの無効化戦略を明確にする

## セキュリティ

### 認証・認可
- JWT トークンは適切に検証
- パスワードは必ずハッシュ化
- 権限チェックは各エンドポイントで実施

### 入力値検証
- Pydanticのバリデーションを活用
- SQLインジェクション対策（ORMの適切な使用）
- XSS対策（適切なエスケープ）

## コード品質（PEP 8準拠）

### Linting & Formatting
- **Black**（フォーマッター）- PEP 8準拠
- **isort**（インポート順序）- PEP 8準拠  
- **flake8**（リンター）- PEP 8チェック
- **mypy**（型チェック）
- **設定例**:

```ini
# setup.cfg
[flake8]
max-line-length = 79
extend-ignore = E203, W503
exclude = .git,__pycache__,migrations

[isort]
profile = black
line_length = 79
multi_line_output = 3

[tool:pytest]
testpaths = tests
```

### Pre-commit hooks
- 上記ツールをpre-commitで自動実行
- PEP 8違反を自動修正
- テストも自動実行

## 禁止事項（PEP 8準拠）

### 避けるべきパターン
- **タブとスペースの混在**（スペースのみ使用）
- **行末の空白**
- **魔法の数値**（マジックナンバー）
- **深すぎるネスト**（4レベル以上）
- **長すぎる関数**（30行以上）
- **PEP 8違反**（行の長さ、空白使用など）

```python
# ❌ Bad - PEP 8違反例
def process_data(data):
    # 行が長すぎる
    result = some_very_long_function_name_that_exceeds_the_line_limit(argument_one, argument_two, argument_three)
    
    # 空白の使い方が間違い
    for item in data:
        if item>10:# コメントの前にスペースがない
            if item<100:
                if item%2==0:# 演算子の前後にスペースがない
                    if item!=50:# ネストが深すぎる
                        pass

# ✅ Good - PEP 8準拠
MAX_THRESHOLD = 10
MIN_THRESHOLD = 100

def process_data(data: List[int]) -> List[int]:
    """Process data according to business rules."""
    result = []
    
    for item in data:
        if item <= MAX_THRESHOLD:
            continue
            
        if item >= MIN_THRESHOLD:
            continue
            
        if item % 2 == 0 and item != 50:
            result.append(item)
            
    return result
```

### パフォーマンスの罠
- 同期処理のDB操作
- N+1クエリ
- 不必要なデータの取得
- メモリリークの原因となるコード

## まとめ

このコーディング規約は、**可読性**、**保守性**、**パフォーマンス**のバランスを重視しています。

- コードは書くよりも読まれることが多いため、可読性を最優先
- 将来の変更に対応できるよう、適切な抽象化と分離を実施
- パフォーマンスは測定可能な問題が発生してから最適化

規約は必要に応じて進化させ、プロジェクトの成長に合わせて調整してください。